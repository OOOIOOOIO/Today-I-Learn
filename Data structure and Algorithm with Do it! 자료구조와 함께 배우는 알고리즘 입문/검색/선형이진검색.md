# 선형 검색(linear search)
 
>&nbsp;기본 O(n)이다. n이란 요소수의 개수인데, 요소를 하나하나 검사하므로 총 검사 횟수는 n회이다. 
배열이 무작위로 나열되어 있는 경우 사용한다. 	

<br>

# 이진 검색(binary search)
			
>&nbsp;기본 O(log n)이다. log n이란 n을 2로 나눈 것을 말한다. 다시말해 횟수를 절반으로 줄이는 것이다.
배열이 오름차순 혹은 내림차순으로 나열되어 있는 경우 사용한다. 처음 중간 끝 세개의 변수를 이용해 범위를 절반으로 줄여나가는 방식이다.

<br>

# JAVA 제공 메서드
>&nbsp;JAVA에서는 Arrays.binarySearch(배열, key값) 메서드를 제공한다. 검색하고자 하는 key값이 배열에 존재할 경우
검색에 성공하여 key값과 일치하는 "인덱스번호"를 리턴한다. java에서 제공하는 binarySerarch는 lower bound 형식이다.<br>
&nbsp;검색에 실패할 경우 key값보다 큰 요소 중 첫번째 인덱스번호를 리턴하는데, 리턴 값은 "-인덱스번호-1" 이다. 항상 음수 값이 나온다.<br>
&nbsp;만약 [1, 3, 5, 7, 9 ,11, 13] 이라는 배열이 있을 때 key값을 6으로 줘보자. 결과는 검색에 실패할 것이고 
리턴 값은 -3 -1 = -4 가 될 것이다.(6보다 큰 요소중 첫번째 요소는 "7"이고 이것의 인덱스 번호는 3이다.)
- static int binarySerch(Object[] a, Object key)

- static int binarySearch(T[], T key, Comparator<? super T>)

<br>

# 정렬

>&nbsp;JAVA에서는 정렬은 되어있지만"자연 순서"로 정렬되어 있지 않거나 "자연 순서"를 논리적으로 갖지 않느 객체 배열을 검색하고자 할 때
Arrays.binarySerrch(T[], T key, Comparator<? super T>를 제공한다.<br>
&nbsp;사실 binarySerch 메서드 안에는 String 클래스가 Comparator 인터페이스를 implements 해 compareTo 메서드를
구현하고 있기 때문에 따로 Comparator를 정의하지 않고 배열과 키 값을 파라미터로 넘겨주어 검색할 수 있는 것이다.

- 문자열 정렬 : page1, page10, page100, page1000, page2, page20, page200 ... 이런식(컴퓨터의 문자열 정렬)

- 자연 정렬 : page1, page2, page10, page21, page200(이런식)


```java
package 검색;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

// p128 
public class 선형이진검색 {
	
	static class PhyscData{
		
		private String name;
		private int height;
		private double vision;
		
		public PhyscData(String name, int height, double vision) {
			this.name = name;
			this.height = height;
			this.vision = vision;
		}
		
		private static class HeightOrderComparator implements Comparator<PhyscData>{
			
			@Override // Comparator --> 1 : 내림차순, -1 : 오름차순, 0 : 그대로
			public int compare(PhyscData o1, PhyscData o2) {
				return o1.height > o2.height ? 1 : o1.height < o2.height ? -1 : 0;
			}
		}
		
		
		@Override
		public String toString() {
			return name + " " + height + " " + vision;
		}
		
		public static final Comparator<PhyscData> HIGHT_ORDER = new HeightOrderComparator();
		
		
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		PhyscData[] x = {
				new PhyscData("이효리", 163, 0.2),
				new PhyscData("김태희", 165, 0.9),
				new PhyscData("이나영", 170, 0.5),
				new PhyscData("원빈", 172, 0.7),
				new PhyscData("기타아저씨", 178, 0.6),
				new PhyscData("비", 180, 0.4),
				new PhyscData("김성호", 182, 0.3)
		};
		
		System.out.println("몇 cm인 사람을 찾고 있습니까?");
		
		int height = sc.nextInt();
		// 배열, 키, 컴패레이터
		int idx = Arrays.binarySearch(x, new PhyscData("", height, 0.0), PhyscData.HIGHT_ORDER);
		if(idx < 0) {
			System.out.println("요소가 존재하지 않습니다");
		}
		else {
			System.out.println("x["+idx+"]에 있습니다.");
			System.out.println("찾은 데이터 : " + x[idx]);
		}
		
		// 문자열 정렬(1, 10, 100, 3, 30, 300)
		String[] arr = {
				"텍스트1.txt",
				"텍스트3.txt",
				"텍스트30.txt",
				"텍스트10.txt",
				"텍스트300.txt",
				"텍스트100.txt"
		};
		Arrays.sort(arr);
		
		for(int i = 0; i < arr.length; i++) {
			System.out.println(arr[i]);
		}
		
		// 자연 정렬(1, 10, 100, 3, 30, 300) --> 잘라서 해야됨
		String[] arr2 = {
				"텍스트1.txt",
				"텍스트3.txt",
				"텍스트30.txt",
				"텍스트10.txt",
				"텍스트300.txt",
				"텍스트100.txt"
		};
		Arrays.sort(arr2);
		
		for(int i = 0; i < arr.length; i++) {
			System.out.println(arr[i]);
		}
	}
}



```
