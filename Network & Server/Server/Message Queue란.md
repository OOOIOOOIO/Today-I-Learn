# Message Queue(MQ) 모델

![image](https://user-images.githubusercontent.com/74396651/234549968-3dc5e4bf-eaf1-485a-9572-810cb8a70620.png)

- Queue는 First-In First-Out의 자료구조이다. 즉, 메시지 큐는 들어온 메시지 저장하고 들어온 순서대로 컨슈머에 전달되어 처리되는 구조이다.
- 여러 컨슈머를 사용하면 높은 속도로 일을 처리할 수가 있다. 각각의 컨슈머는 메시지를 하나씩 전달받고 병렬적으로 작업을 처리하게 된다. 메시지 큐 모델은 메시지의 단일 처리를 보장하는데, 이를 위해 메시지가 컨슈머에 전달되어 처리되면 큐에서 삭제된다.
- 네트워크나 컨슈머의 문제가 생겨 전송되지 못한 메시지의 경우 별도의 Dead Letter Queue로 저장된다. 이 큐는 재처리, 무시, 관리자가 직접 처리 등 다양한 방식으로 처리를 할 수 있다. 재처리로 메시지를 새로 메시지 큐에 넣게 되면, 메시지의 순서를 보장하지 못하게 된다.
  - 대표적인 예시가 정산 시스템이다. 정산은 속도가 빠르면 좋고, 순서는 상관없으며, 한 번씩만 처리되는 것이 매우 중요하기 때문에 메시지 큐를 이용하기 매우 적합하다.
- 메시지 큐 모델을 기반으로 만들어진 기술은 Apache ActiveMQ, Amazon SQS, IBM Websphere MQ, RabbitMQ 등이 있다.

## MQ 구조(RabbitMQ)

![image](https://user-images.githubusercontent.com/74396651/234551602-6a32dbf2-974c-4d74-ae6e-1d8e687e9b6e.png)

> 여기서 Broker는 송신자(Sender)와 수신자(Receiver) 사이에서 메세지의 전달을 중재하는 컴퓨터 프로그램 모듈이다.

![image](https://user-images.githubusercontent.com/74396651/234551663-22463384-b1bf-4a6b-b535-86afbd9fe92d.png)

<hr>

## MQ 장점
- 비동기 (Asynchronous):큐(Queue)에 넣기 때문에 나중에 처리할 수 있다.
- 비동조 (Decoupling) : 애플리케이션(Application)과 분리할 수 있다.
- 과잉 (Redundancy)	: 실패할 경우 재실행이 가능하다.
- 보증 (Guarantees)	: 작업이 처리된 것을 확인할 수 있다.
- 확장성 (Scalable) : 다수의 프로세스들이 큐에 메세지를 보낼 수 있다.

## MQ를 사용하는 경우
- 애플리케이션 & 시스템 간의 통신
   - 서버 간에 데이터를 주고 받거나 어떤 작업을 요청을 할 때는 항상 시스템 장애를 염두에 두어야 한다. 서버가 갑자기 죽거나 서버 점검 등으로 다운타임이 발생하는 동안에는 요청을 보낼 수가 없다. 요청하는 서버에서 failover 처리를 해놓고 연계 시스템이 다시 살아났을 때 요청을 보내는 방법도 있지만 MQ를 이용하면 더욱 간편하게 처리할 수 있다.
- 서버 부하가 많은 작업
  - 이미지 처리, 비디오 인코딩, 대용량 데이터 처리와 같은 작업은 메모리와 CPU를 많이 사용한다. 이러한 작업은 동시에 처리할 수 있는 양이 상당히 한정적이어서 필요하다고 무작정 요청을 처리할 수는 없다. 이 때에도 MQ를 사용하면 편리한데 처리해야할 작업을 MQ에 넣어두고 서버는 자신이 동시에 처리할 수 있는 양에 따라 하나의 작업이 끝나면 다음에 처리할 작업을 MQ에서 가져와 처리하면 된다.

- 부하 분산
  - MQ를 통해 부하분산 처리도 가능하다. 여러 대의 서버가 하나의 큐를 바라보도록 구성하면 처리할 데이터가 많아져도 각 서버는 자신의 처리량에 맞게 태스크를 가져와 처리할 수 있다.

- 데이터 손실 방지
  - MQ를 사용하지 않는다면 외부에서 받은 요청을 메모리에 저장했다가 들어온 순서대로 처리하게 할 수도 있다. 하지만 어떠한 이유로 서버가 다운되어 버리면 메모리에 쌓아둔 요청은 모두 없어지고 만다. MQ를 사용하면 이를 방지할 수 있는데 MQ로부터 가져온 태스크를 일정 시간이 지나도록 처리했다고 다시 MQ에 알려주지 않으면 MQ는 이 태스크를 다시 큐에 넣어 다시 처리할 수 있도록 한다.


<br>
<br>
<br>
<br>
<br>

[참고](https://tecoble.techcourse.co.kr/post/2021-07-03-message-oriented-middleware/)
