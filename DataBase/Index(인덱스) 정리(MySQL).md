# Index(인덱스)란

![image](https://user-images.githubusercontent.com/74396651/233569304-9568b54f-4cda-457a-9305-067821685053.png)

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 만약 우리가 사전에서 원하는 단어를 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다. 그렇기 때문에 알파벳에 따라 색인을 추가한다. 데이터베이스의 index는 위 사전의 색인과 같다.<br>
데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.

<hr>

# 인덱스가 쿼리에 미치는 영향

![image](https://user-images.githubusercontent.com/74396651/233577153-f949c20f-1c55-4e36-a629-e20f8885e14f.png)

- INSERT: 새로운 데이터에 대한 인덱스를 추가함
  - INSERT로 인한 페이지 분할
    - 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생하는 것
    - DB가 느려지고 성능에 영향을 준다.
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함
  - DELETE를 통해 기존의 인덱스를 사용하지 않음 처리
  - INSERT를 통해 데이터에 변경된 값 삽입 
  
DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. Where 절로 처히라 대상을 찾기 위한 조회 성능은 향상된다. 하지만 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE를 수행할 경우 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다. 만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다. 인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 한다. 

<hr>

# 인덱스를 사용하면 좋은 경우
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

<hr>

# 인덱스 장단점 
- 장점
  - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
  - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점
  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
  - 인덱스를 관리하기 위해 추가 작업이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

<hr>

# 인덱스 적용 기준
- ### Cardinality(카디널리티)
> the number of elements in a set or group
- 한 테이블이 다른 테이블과 가질 수 있는 관계(다대다, 다대일, 일대다 등)를 나타내거나 전체 행에 대한 특정 컬럼의 고유 값의 개수를 나타낸다. 여기서 사용되는 의미는 후자이다. 카디널리티가 높다(크다)라는 뜻은 중복도가 낮다는 의미이다. 따라서 카디널리티가 높은 컬럼에 인덱스를 걸어주자.

- ### Where, Join, Order By, 절에 자주 사용되는 컬럼
인덱스는 추가 공간이 필요로 한다. 조건 절을 사용하지 않느다면 인덱스도 사용되지 않는다.

- ### INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼

- ### 규모가 작지 않은 테이블

<hr>

# 인덱스 알고리즘
### Full Table Scan

![image](https://user-images.githubusercontent.com/74396651/233573867-afc129ec-d7a5-4858-aa28-aa5ecfd1e0a0.png)

- 사용되는 경우
  - 적용 가능한 인덱스가 없는 경우
  - 인덱스 처리 범위가 너무 넓은 경우
  - 크기가 작은 테이블에 엑세스 하는 경우
- 특징
  - 순차적으로 접근한다.
  - 접근 비용이 감소한다.

### B-Tree, B+Tree
[여기서 정리](https://github.com/OOOIOOOIO/Today-I-Learn/blob/master/DataBase/B-Tree%20%26%20B%2BTree%20%EC%A0%95%EB%A6%AC.md)

<br>

# 인덱스 종류
### 클러스터링 인덱스

![image](https://user-images.githubusercontent.com/74396651/233579043-ff5b1236-0817-4818-a507-153acbbce0be.png)

- 실제 데이터에 인덱스가 적용된다.(실제 데이터 자체가 정렬되어 있다.)
- 테이블당 한 개만 생성이 가능하다.
- 리프 페이즈 == 데이터 페이지
- primary key 제약조건 생성 시
- not null + unique 제약조건 생성 시
  -  PK와 not null + unique가 동시에 걸릴 경우 PK가 우선순위가 더 높다.

### 논-클러스터링 인덱스(보조 인덱스, 세컨더리 인덱스)

![image](https://user-images.githubusercontent.com/74396651/233579671-d706f916-8ce8-4111-bc53-9efbc47216d5.png)

- 실제 데이터 페이지와 다른 별도 인덱스 페이지가 생성된다.
- 테이블 당 여러 개 존재 가능하다.
- 리프 페이지에 실제 데이터 페이지의 주소를 담고 있다.
- unique 제약조건 생성 시
- unique index 제야조건 생성 시
- 직접 idex 생성 시

### 클러스터링 + 논-클러스터링 인덱스가 같이 있을 경우

![image](https://user-images.githubusercontent.com/74396651/233581925-aa3e1887-3880-4b6f-80d4-7f0d94823ed9.png)
- 위 사진의 경우 name 컬럼이 논 클러스터링 인덱스로, id 컬럼이 클러스터링 인덱스로 적용되어 있다. where name컬럼 쿼리를 실행할 경우 name을 논-클러스터링 인덱스에서 찾고 name에 해당하는 id를 다시 클러스터링 인덱스를 통해 찾게 된다.
- 원래 논-클러스터링 인덱스는 id값이 아닌 주소값이 들어있었다. 하지만 id(클러스터링 인덱스)가 들어있는 것을 확인할 수 있었는데 이는 페이지 분할이 발생할 경우 인덱스 페이지들의 주소가 계속 변경되기 때문에 성능에 영향을 미친다. 따라서 변경에 따른 성능 이슈를 줄이고자 id값을 주소 대신 가지게 된다.

<br>
<br>
<br>
<br>
<br>


[우테코 유툽](https://www.google.com/search?q=index%EB%9E%80+%EC%9A%B0%EC%95%84%ED%95%9C&oq=index%EB%9E%80+%EC%9A%B0%EC%95%84%ED%95%9C&aqs=chrome..69i57.3663j0j15&sourceid=chrome&ie=UTF-8#fpstate=ive&vld=cid:486b9f9c,vid:edpYzFgHbqs)
[참고2](https://mangkyu.tistory.com/96)
