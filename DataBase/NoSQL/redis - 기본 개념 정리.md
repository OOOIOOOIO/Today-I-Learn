# Redis란
> 레디스는 고성는 키-밸류 저장소로서 문자열, 리스트, 해시, 셋, 정렬된 셋 형식의 데이터를 지원하는 NoSQL이다.
Redis는 Memcached와 비슷한 캐시 시스템으로서 동일한 기능을 제공하면서 영속성, 다양한 데이터 구조와 같은 부가적인 기능을 지원하고 있다. 레디스는 모든 데이터를 메모리에 저장하고 조회한다. 즉, 인메모리 데이터베이스이다. 이 말만 들으면 Redis에 모든 데이터를 메모리에 저장하는 빠른 DB가 다라고 생각할지도 모른다. 하지만 빠른 성능은 레디스의 특징 중 일부분이다. 다른 인메모리 디비들과의 가장 큰 차이점은 레디스의 다양한 자료구조이다.

## Redis는 Single Thread이다.
### 레디스의 코어스레드는 싱글스레드!

![image](https://user-images.githubusercontent.com/74396651/231174553-2ac0377b-2eef-4702-a7ce-dd3b415cbaa3.png)

> 레디스는 사용자들이 실행한 명령어들을 이벤트 루프(event loop) 방식으로 처리한다. 즉, 클라이언트가 실행한 명령어들을 Event Queue에 적재하고 싱글 스레드로 하나씩 처리한다. 메모리를 사용하기 때문에 싱글 스레드로 데이터를 빠르게 처리할 수 있다.

- 장점
  - 멀티 스레드 환경이 아니라 Context Switch 발생 X → 효율적인 시스템 리소스 사용 가능
  - 1번과 같은 이유로 Deadlock 발생 X
- 단점
  - 싱글 스레드 이므로 전체 데이터 스캔과 같은 오버헤드가 큰 명령어를 처리하는 동안 다른 명령어를 처리 불가.
  - 이 때, 다른 명령어들은 이벤트 큐에 저장되어 있는 시간이 길어짐. → 응답 속도 저하

<br>

![image](https://user-images.githubusercontent.com/74396651/229419629-be4c3a32-673a-4031-a64f-6b3ccf4126c4.png)

- 이렇게 다양한 자료구조를 지원하게 되면 개발의 편의성이 좋아지고 난이도가 낮아진다는 장점이 있다.
- 예를들어, 어떤 데이터를 정렬을 해야하는 상황이 있을 때, DBMS를 이용한다면 DB에 데이터를 저장하고, 저장된 데이터를 정렬하여 다시 읽어오는 과정은 디스크에 직접 접근을 해야하기 때문에 시간이 더 걸린다는 단점이 있다. 하지만 이 때 In-Memory 데이터베이스인 Redis를 이용하고 레디스에서 제공하는 Sorted-Set이라는 자료구조를 사용하면 더 빠르고 간단하게 데이터를 정렬할 수 있다.

<br>

## Redis 특징

![image](https://user-images.githubusercontent.com/74396651/229419796-26fe1c2f-28a5-4c5a-a923-1f4b814ae567.png)

> NoSQL로서 Key-Value 타입의 저장소인 레디스(Redis, Remote Dictionary Server)의 주요 특징은 아래와 같다.

- 영속성을 지원하는 인메모리 데이터 저장소
- 읽기 성능 증대를 위한 서버 측 복제를 지원
- 쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding) 지원
  - Sharding이란 파티셔닝과 동의어이다.
- 다양한 서비스에서 사용되며 검증된 기술
- 문자열, 리스트, 해시, 셋, 정렬된 셋과 같은 다양한 데이터형을 지원. 메모리 저장소임에도 불구하고 많은 데이터형을 지원하므로 다양한 기능을 구현

<br>

## Redis 영속성
![image](https://user-images.githubusercontent.com/74396651/231175978-a3a165a8-f8df-4a09-8912-5bb30bad8d23.png)


> 레디스는 지속성을 보장하기 위해 데이터를 DISK에 저장할 수 있다. 서버가 내려가더라도 DISK에 저장된 데이터를 읽어서 메모리에 로딩한다.
Redis는 데이터를 DISK에 저장하는 방식은 크게 두 가지 방식이 있다.

1) RDB (Redis Database) : 메모리에 있는 데이터 전체에서 스냅샷을 작성하고, 이를 디스크로 저장하는 방식
- 특정 시간마다 여러 개의 스냅샷을 생성하고, 데이터를 복원해야 한다면 스냅샷 파일을 그대로 로딩만 하면 됨.
- 하지만, 스냅샷 이후 변경된 데이터는 복구할 수 없음. → 데이터 유실(loss)

2) AOF (Append Only File) : 데이터가 변경되는 이벤트가 발생하면 이를 모두 로그에 저장하는 방식
- 데이터를 생성, 수정, 삭제하는 이벤트를 초 단위로 취합 및 로그 파일에 작성
- 모든 데이터의 변경 기록들을 보관하고 있으므로 최신 데이터 정보를 백업 가능
- RDB 방식에 비해 데이터 유실량이 적음(초 단위 데이터는 유실 가능).
- RDB 방식보다 로딩 속도가 느리고 와 파일 크기가 큰 것이 단점

### RDB, AOF 무엇을 선택할까
⇒ 일부 데이터 손실에 영향을 받지 않는 경우(캐시로만 사용할 때), RDB
⇒ 장애 상황 직전까지의 모든 데이터가 보장되어야 할 경우, AOF
⇒ 강력한 내구성이 필요한 경우, RDB + AOF
⇒ 레디스는 일반적으로 AOF와 RDB를 동시에 사용하여 데이터를 백업한다.
> 예를 들면, 매일 7시마다 RDB 스냅샷을 생성하고, RDB 생성 이후에 변경되는 데이터는 AOF로 백업.


<br>

## Redis 백업 방식
- RDB(Snapshotting) 방식
  - 순간적으로 메모리에 있는 내용을 DISK에 전체를 옮겨 담는 방식
  - 자동 : Redis.conf 파일 → SAVE 옵션 설정 (시간 기준)
  - 수동 : redis-cli에서 BGSAVE 커맨드를 이용하여 수동으로 RDB 파일 저장
    - SAVE 커맨드는 절대 사용 X (레디스는 싱글 스레드, 저장하는 동안 다른 작업 수행 불가)
- AOF (Append On File) 방식
  - Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태
  - 자동 : redis.conf 파일 → auto-aof-rewrite-percentage 옵션 설정 (크기 기준)
  - 수동 : redis-cli에서 BGREWRITEAOF 커맨드를 이용하여 수동으로 AOF 파일 재작성

<br>

## Redis 아키텍처
- Redis Topology
  - Redis는 Master-Slave 형태로 데이터를 복제해서 운영할 수 있다.
  - Master-Slave 간 복제는 Non-Blocking 상태로 이루어진다.
- Redis Sharding
  - Redis에서 데이터를 샤딩하여 Read 성능을 높일 수 있다.
- Rdeis Cluster
  - Redis는 클러스터링을 지원하기에 실무에서는 주로 클러스터로 묶어서 가용성 및 안정성 있는 캐시 매니저로 사용하고 있다.

<br>

## Redis 스키마
사용자의 이메일, 닉네임, 최근 로그인 시간을 저장해보자.
- user:userId:email:polite159@gmail.com(문자열)
- user:userId:nickname:polite159(문자열)
- user:userId:lastLogin:2023-04-03(문자열)
- 스키마를 활용하면 사용자 아이디에 해당하는 userId만 알아도 연결된 데이터인 email, nickname, lastLogin도 알 수 있게 된다.


<br>

## Redis 사용용도
- 주 데이터 저장소 : AOF, RDB 백업 기능과 레디스 아키텍처를 사용하여 주 저장소로 데이터를 저장할 수 있다. 하지만 메모리 특성상 용량이 큰 데이터 저장소로는 적절하지 않다.
- 데이터 캐시 : 인메모리 데이터 저장소이므로 주 저장소의 데이터를 캐시하여 빠르게 데이터를 읽을 수 있다. 캐시된 데이터는 한곳에 저장되는 중앙 집중형 구조로 구성한다. → 데이터 일관성 유지 가능
- 분산 락(distributed lock) : 분산 환경에서 여러 시스템이 동시에 데이터를 처리 할 때는 특정 공유 자원의 사용 여부를 검증하여 데드 락을 방지할 필요가 있다. 이때 레디스를 분산 락으로 사용할 수 있다.
- 순위 계산 : 레디스에서 제공하는 ZSet(Sorted Set) 자료 구조를 이용하여 순위 계산 용도로 사용하기도 한다. ZSet은 정렬 기능이 포함된 Set 자료 구조이므로 쉽고 빠르게 순위를 계산할 수 있다.

<br>

## 사용시 주의할 점
- 장애가 났을 경우 그에 대비한 운영 플랜이 세워줘야 함
Redis는 인메모리 데이터 저장소로서 서버에 장애가 났을 경우 데이터 유실이 발생합니다. 따라서 위의 Snapshot과 AOF 기능을 통한 복구 시나리오가 제대로 세워져 있어야 데이터 유실에 대비한 사고에 대처할 수 있다.


- 캐시 솔루션으로 사용할 시 잘못된 데이터가 캐시되는 것을 방지, 예방해야 함
Redis를 운영 중 전에 개발자의 실수로 작성된 로직으로 캐시 데이터가 잘못 캐싱되어 올바르지 않은 데이터가 FETCH되어 한동안 데이터가 꼬이는 일이 있다. 레디스와 캐싱하고자 하는 데이터 저장소의 데이터가 서로 일치하는 지 주기적인 모니터링과 이를 방지하기 위한 솔루션을 개발하는 것이 좋다.




   
   
   
