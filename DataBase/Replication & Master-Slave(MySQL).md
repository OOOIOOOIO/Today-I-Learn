# Replication
MySQL에서 Replication이란 복제하는 것이다. 물리적으로 다른 서버의 저장 공간 안에 동일한 데이터를 복사하는 기술이다. 엄격하게 MySQL Replication은 데이터를 이중화하는 개념이다.<br>
오직 단일 마스터에서만 데이터 변경 작업을 수행할 수 있다. 쓰기 부하 분산은 불가능하지만 읽기 부하 분산은 가능하다. 또한 특정 노드 디스크에 장애가 터졌을 때 전체 데이터 유실로 이어지지 않는다.

## 복제 메커니즘
![image](https://github.com/OOOIOOOIO/Today-I-Learn/assets/74396651/d643e2e0-4f79-4409-827c-68aafe1639d3)

1. Master DB에 데이터 변경이 일어나면 Master DB에 반영한다.
2. Master DB에서 변경된 이력을 Binary Log에 기록 후 관련 이벤트를 Slave DB에 전달한다.
3. Slave SQL_THREAD는 Relay Log를 읽고 Slave DB에 기록을 합니다.
4. 기억해야할 사항은 Master에서는 여러 세션에서 데이터 변경 처리가 가능하지만(멀티스레딩), Slave에서는 오직 하나 SQL Thread에서만 데이터 변경 처리가 가능한 점아다. 그렇기 때문에 Master에 데이터 변경 트래픽이 과도하게 몰리게 되면 Master/Save 간 데이터 동기화 시간이 크게 벌어질 수도 있다.


# Master-Slave

## 구조
![image](https://github.com/OOOIOOOIO/Today-I-Learn/assets/74396651/37c6f8af-8ec5-43be-87fc-236dcf2eba00)

일반적으로 DB 트랙픽 부하분산을 위해 MySQL Replication을 통해 해결할 수 있다.
Master DB는 동시성 처리가 요구되는 트랜잭션, 쓰기를 담당하고 Slave DB는 읽기를 담당한다.

## 주의할 점
- 슬레이브는 하나의 마스터만 설정 가능하다.
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정한다.
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합하다.
- 여러 개의 스레드로 실행된 쿼리가 슬레이브에서 지연되지 않고 하나의 스레드로 처리될 수 있다.
- 데이터 변경은 데이터 조회보다는 10분의 1 수준으로 유지되는 것이 일반적이므로 마스터 서버와 슬레이브 서버를 같은 사양으로 유지할 때가 많다. 또한, 슬레이브 서버는 마스터 서버가 다운된 경우 그에 대한 복구 대안으로 사용될 떄도 많기 때문에 사양을 동일하게 맞추는 경우가 대부분이다.
- 복제가 불필요한 경우에는 바이너리 로그를 중지한다.
- 바이너리 로그를 안정적으로 기록하기 위해 갭 락(Gap lock)을 유지하고, 매번 트랜잭션 이 커밋될 때 마다 데이터를 변경시킨 쿼리 문장을 바이너리 로그에 기록해야 한다. 바이너리 로그를 기록하는 작업은 AutoCommit이 활성화 된 MySQL 서버에서 심각한 부하로 나타날 때가 많다.
- 바이너리 로그와 트랜잭션 격리 수준(Isolation level)
  - 바이너리 로그 파일은 어떤 내용이 기록되냐느에 따라 STATEMENT 포맷 방식과 ROW 포맷 방식이 있다.
- STATEMENT 방식은 바이너리 로그 파일에 마스터에서 실행되는 쿼리 문장을 기록하는 방식이며, ROW 포맷은 마스터에서 실행된 쿼리에 의해 변경된 레코드 값을 기록하는 방식이다.
- MySQL의 복제는 마스터에서 처리된 내용이 바이너리 로그로 기록되고, 그 내용이 슬레이브 MySQL 서버로 전달되어 재실행 되는 방식으로 처리된다.
- 바이너리 로그 파일에 SQL 문장을 기록하는 방식을 문장 기반 복제 라고 하며, 변경된 레코드를 바이너리 로그에 기록하는 방식을 레코드 기반의 복제라고 한다.
  - 문장 기반 복제에는 Mysql Replication시 주의해야할 점이 있다. master 서버에 쓰기 작업이 일어나고 slave 서버에 복제가 되기 전에 slave 서버에 읽기 요청이 일어난다면, 일관되지 않는 값을 얻게 된다. 
  - 따라서, SQL 기반의 복제가 정상적으로 작동하려면 REPEATABLE-READ 이상의 트랜잭션 격리 수준을 사용해야 하며, 그로 인해 InnoDB 테이블에서는 레코드 간의 간격을 잠그는 갭락이나 넥스트 키 락이 필요하다.
- 반면 레코드 기반의 복제는 마스터 슬레이브 MySQL 서버 간의 네티워크 트레픽을 많이 발생시킬 수 있지만 READ-COMMITTED 트랜잭션 격리 수준에서도 작동할 수 있으며 InnoDB 테이블에서 잠금의 경합은 줄어들게 된다.

 



<br>
<br>
<br>
<br>

[참고](https://banggucha.tistory.com/entry/MySQLMariaDB-Replication-%EC%84%A4%EB%AA%85)
[코드 참고, 하는 법](https://junghyungil.tistory.com/177)
