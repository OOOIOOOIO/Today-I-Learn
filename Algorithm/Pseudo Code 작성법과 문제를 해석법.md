 # Pseudo Code
 > 정해진 형식이 없다! 구현하기 전에 틀을 잡는 것

## 지키면 좋은 규칙
 - How to do(구현방식) 대신 What to do(생각) 방식으로 서술
   - What to do ex) 점수를 입력받고 총합을 구한다.
   - How to do ex) 3과목 점수를 각각 배열에 입력을 받은 후 반복문을 돌며 점수를 더한다.
 - 분기나 반복이 되는 경우 명시적으로 표현
   ```
   if(물이 끓으면){
    면을 넣는다;
    } -> 의식의 흐름대로
    
    or
    
    1. 성적 입력
    2. 성적이 60점을 넘는지 확인(분기)
      2-1. 60점 이상이면 PASS
      2-2. 60점 이하라면 FAIL
   ```
 - 문제 해결 순서가 순차적으로 나타나도록 표현
 - 문장은 최대한 간결하게 표현(3형식 이하)
 - depth는 되도록 2개 이하, 3개를 초과하지 않도록 노력! 함수로 빼버리자!!

## 중점사항
- 입력값과 반환값을 항상 고려
- 처읍부터 완벽하게 하려고 하지 말 것!!! 나한테 중요
- 의사코드 작성과정에서 코드를 고민하지 말 것!!!! 나한테 중요

## 예시

### 문제 : N을 받고 1~N까지 더한 값을 반환하는 동작
```
N : input
sum : 0
i = 1

for(i : 1 to N){
  sum += i;
}

return sum;

```

<hr>

# 문제 해석

## 문제를 해석하는 순서
1. 문제를 분석한다.
  1-1. 입출력 부분 정리
  1-2. 중요한 키워드나 문장 분석
3. 본인만의 언어로 문제를 재해석한다.
4. 필요시 직접 예제 입출력을 만들어본다. 합정, 최악의 경우들을 고려해본다.
5. 문제를 작은 문제로 여러개 쪼갤 수 있다면 쪼갠다.(Pseudo Code를 작성한다는 말과 같은 의미이다)



```
< 문제 키워드 >
sorted : 데이터의 방향 존재, 중복된 원소는 붙어있음
in-place : 추가적으로 배열을 선언하지 말고, 인자로 받은 배열을 수정해야 함
O(1) extra memory : 추가 배열선언 불가능, 변수만 선언 가능

< 알고리즘 키워드 >
최적의 해 : DFS, Greed 제외. BFS를 충분히 고려해보자
정렬된 상태의 데이터 : 이진탐색, Parametric Search 고려
삽입삭제가 빈번하게 일어남 : 힙 고려
최단 경로 : 다익스트라, 벨만포드, 플로이드 워셜

< 입력값 키워드 >
데이터 10000만개 이상(10,000,000) : 복잡도 NlogN 이상 알고리즘은 답이 될 수 없음
데이터 10만개 이상(100,000) : 복잡도 N^2 이상 알고리즘은 답이 될 수 없음
데이터 1000개 이하 : Brute Force 고려할만 함
데이터 50개 미만인 경우 하드코딩을 통해 데이터를 만들어 놓는게 해답일 수 있다.


```

## 코드를 구현하는 과정
- Pseudo code를 기반으로 만들었던 입출력이 잘 동작하는지 체크
- 예외케이스가 있다면 Pseudo code에 추가!

## 코드로 구현하는 부분
- 모듈화가 필요한 부분은 함수를 정의
- 반복문의 경우 Pseudo code에 range 표시
- 필요한 자료구조나 알고리즘이 있다면 표시









